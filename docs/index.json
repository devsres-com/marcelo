[{
    "title": "Calicoctl, TLS e gestão de certificados",
    "date": "",
    "description": "O que fazer quando nem o modo DEBUG das ferramentas te dá uma dica?",
    "body": "Estava precisando configurar algumas GlobalNetworkPolicies em um cluster Kubernetes; para isso, é necessário intervir diretamente no Calico, pois o Kubernetes ainda não conta com objetos de Networkpolicies que não sejam \u0026lsquo;namespaced\u0026rsquo;.\nObviamente, usamos \u0026lsquo;backend\u0026rsquo; ETCD: por que simplificaríamos tudo usando CRDs no próprio Kubernetes, não é? Deixamos isso para os amadores!\n(PS: fazemos assim porque somos tão pioneiros em usar tecnologias \u0026lsquo;bleeding edge\u0026rsquo; que, à época da implantação, usar Kubernetes como backend sequer era uma opção - sim, nós somos \u0026lsquo;that old school\u0026rsquo;! Ah, e naturalmente, somos preguiçosos demais para migrar agora.)\nMas voltando ao assunto\u0026hellip;\n\u0026ldquo;Calico, dê-me informações!\u0026rdquo;\n$ calicoctl -l debug get globalnetworkpolicies _ NADA!\nPutz, caíram minhas regras de firewall de novo?\nChamei um teste de conectividade nas portas, tudo ok:\n$ for i in 192.168.0.11 192.168.0.12 192.168.0.13 ; do { timeout 1 curl -svz1 telnet://$i:2379 2\u0026gt;\u0026amp;1 ; } | grep Connected; done * Connected to 192.168.0.11 (192.168.0.11) port 2379 (#0) * Connected to 192.168.0.12 (192.168.0.12) port 2379 (#0) * Connected to 192.168.0.13 (192.168.0.13) port 2379 (#0) Nah, tudo ok.\nDEBUG, ATIVAR:\n$ calicoctl -l debug get globalnetworkpolicies INFO[0000] Log level set to debug INFO[0000] Executing config command DEBU[0000] Resource: projectcalico.org/v3, Kind=Node DEBU[0000] Data: - apiVersion: projectcalico.org/v3 kind: Node metadata: creationTimestamp: null spec: {} status: {} DEBU[0000] Loading config from JSON or YAML data DEBU[0000] Datastore type: etcdv3 INFO[0000] Loaded client config: apiconfig.CalicoAPIConfigSpec{DatastoreType:\u0026quot;etcdv3\u0026quot;, EtcdConfig:apiconfig.EtcdConfig{EtcdEndpoints:\u0026quot;https://192.168.0.11:2379,https://192.168.0.12:2379,https://192.168.0.13:2379\u0026quot;, EtcdDiscoverySrv:\u0026quot;\u0026quot;, EtcdUsername:\u0026quot;\u0026quot;, EtcdPassword:\u0026quot;\u0026quot;, EtcdKeyFile:\u0026quot;/etc/calico/tls/acof/tls.key\u0026quot;, EtcdCertFile:\u0026quot;/etc/calico/tls/acof/tls.crt\u0026quot;, EtcdCACertFile:\u0026quot;/etc/calico/tls/acof/tls.ca\u0026quot;, EtcdKey:\u0026quot;\u0026quot;, EtcdCert:\u0026quot;\u0026quot;, EtcdCACert:\u0026quot;\u0026quot;}, KubeConfig:apiconfig.KubeConfig{Kubeconfig:\u0026quot;\u0026quot;, K8sAPIEndpoint:\u0026quot;\u0026quot;, K8sKeyFile:\u0026quot;\u0026quot;, K8sCertFile:\u0026quot;\u0026quot;, K8sCAFile:\u0026quot;\u0026quot;, K8sAPIToken:\u0026quot;\u0026quot;, K8sInsecureSkipTLSVerify:false, K8sDisableNodePoll:false, K8sUsePodCIDR:false, KubeconfigInline:\u0026quot;\u0026quot;, K8sClientQPS:0}} DEBU[0000] Using datastore type 'etcdv3' INFO[0000] Client: {{{CalicoAPIConfig projectcalico.org/v3} { 0 {{0 0 \u0026lt;nil\u0026gt;}} \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; map[] map[] [] [] []} {etcdv3 {https://192.168.0.11:2379,https://192.168.0.12:2379,https://192.168.0.13:2379 /etc/calico/tls/acof/tls.key /etc/calico/tls/acof/tls.crt /etc/calico/tls/acof/tls.ca } { false false false 0}}} 0xc00000ec18 0xc0001fed70} DEBU[0000] Processing List request list-interface=Node rev= DEBU[0000] Get Global Resource key from /calico/resources/v3/projectcalico.org/nodes DEBU[0000] Didn't match regex DEBU[0000] List options is a parent prefix, ensure path ends in / list-interface=Node rev= DEBU[0000] Adding / to path list-interface=Node rev= DEBU[0000] Calling Get on etcdv3 client etcdv3-etcdKey=/calico/resources/v3/projectcalico.org/nodes/ list-interface=Node rev= Putz, imprime um monte de lixo inútil para a resolução do problema, e trava na requisição ao servidor ETCD do mesmo jeito.\nQual o próximo passo lógico de diagnóstico agora? Tarô? Leitura de mão?\n A chave para a solução do problema passa sutilmente despercebida na diretiva EtcdEndpoints:\n...https://... Esse tipo de erro obscuro, fantasma, de conexões que não começam (ou, no caso, que nunca terminal) são típicos de problemas de validação TLS. Mas que tipo de validação TLS?\nUm programa \u0026ldquo;bem feito\u0026rdquo; normalmente ajuda a depuração. Vamos analisar o comportamento do comando curl quando exposto a diversos problemas de validação TLS:\n Autoridade certificadora inválida:  # curl https://etcd1.local:2379 curl: (60) Peer's Certificate issuer is not recognized.  Nome do servidor não consta no certificado:  # curl --cacert tls/sp2/ca.pem --resolve hostname.invalido:2379:10.99.17.11 https://hostname.invalido:2379 curl: (51) Unable to communicate securely with peer: requested domain name does not match the server's certificate.  O servidor requer autenticação com certificado válido pelo cliente, e vocẽ não enviou nenhum:  # curl --cacert tls/sp2/ca.pem https://etcd1.local:2379 curl: (58) NSS: client certificate not found (nickname not specified) Bem, já é o suficiente.\nO calicoctl, entretanto, deixa bastante a desejar nesse cenário (A Tigera possivelmente acredita que você não terá problemas para reconhecer algo tão bobo?).\nPraticamente todos os erros que envolvem certificados e TLS terminam com o calicoctl travando por tempo indefinido.\n Autoridade certificadora inválida:  # ETCD_ENDPOINTS=https://etcd1.local:2379 calicoctl -l debug get nodes ... INFO[0000] Loaded client config: apiconfig.CalicoAPIConfigSpec{DatastoreType:\u0026quot;etcdv3\u0026quot;, EtcdConfig:apiconfig.EtcdConfig{EtcdEndpoints:\u0026quot;https://etcd1.local:2379\u0026quot;, EtcdDiscoverySrv:\u0026quot;\u0026quot;, EtcdUsername:\u0026quot;\u0026quot;, EtcdPassword:\u0026quot;\u0026quot;, EtcdKeyFile:\u0026quot;\u0026quot;, EtcdCertFile:\u0026quot;\u0026quot;, EtcdCACertFile:\u0026quot;\u0026quot;, EtcdKey:\u0026quot;\u0026quot;, EtcdCert:\u0026quot;\u0026quot;, EtcdCACert:\u0026quot;\u0026quot;}, KubeConfig:apiconfig.KubeConfig{Kubeconfig:\u0026quot;\u0026quot;, K8sAPIEndpoint:\u0026quot;\u0026quot;, K8sKeyFile:\u0026quot;\u0026quot;, K8sCertFile:\u0026quot;\u0026quot;, K8sCAFile:\u0026quot;\u0026quot;, K8sAPIToken:\u0026quot;\u0026quot;, K8sInsecureSkipTLSVerify:false, K8sDisableNodePoll:false, K8sUsePodCIDR:false, KubeconfigInline:\u0026quot;\u0026quot;, K8sClientQPS:0}} ... ^C  Nome do servidor não consta no certificado:  # # Criei uma entrada no /etc/hosts para etcd.devsres.com, o nome não resolve. # ETCD_ENDPOINTS=https://etcd.devsres.com:2379 ETCD_CA_CERT_FILE=tls/tls.ca calicoctl -l debug get nodes ... INFO[0000] Loaded client config: apiconfig.CalicoAPIConfigSpec{DatastoreType:\u0026quot;etcdv3\u0026quot;, EtcdConfig:apiconfig.EtcdConfig{EtcdEndpoints:\u0026quot;https://etcd.devsres.com:2379\u0026quot;, EtcdDiscoverySrv:\u0026quot;\u0026quot;, EtcdUsername:\u0026quot;\u0026quot;, EtcdPassword:\u0026quot;\u0026quot;, EtcdKeyFile:\u0026quot;\u0026quot;, EtcdCertFile:\u0026quot;\u0026quot;, EtcdCACertFile:\u0026quot;tls/tls.ca\u0026quot;, EtcdKey:\u0026quot;\u0026quot;, EtcdCert:\u0026quot;\u0026quot;, EtcdCACert:\u0026quot;tls/tls.ca\u0026quot;}, KubeConfig:apiconfig.KubeConfig{Kubeconfig:\u0026quot;\u0026quot;, K8sAPIEndpoint:\u0026quot;\u0026quot;, K8sKeyFile:\u0026quot;\u0026quot;, K8sCertFile:\u0026quot;\u0026quot;, K8sCAFile:\u0026quot;\u0026quot;, K8sAPIToken:\u0026quot;\u0026quot;, K8sInsecureSkipTLSVerify:false, K8sDisableNodePoll:false, K8sUsePodCIDR:false, KubeconfigInline:\u0026quot;\u0026quot;, K8sClientQPS:0}} ... ^C  O servidor requer autenticação com certificado válido pelo cliente, e vocẽ não enviou nenhum:  # ETCD_ENDPOINTS=https://sp2srvvpkv00001:2379 ETCD_CA_CERT_FILE=tls/tls.ca calicoctl -l debug get nodes ... INFO[0000] Loaded client config: apiconfig.CalicoAPIConfigSpec{DatastoreType:\u0026quot;etcdv3\u0026quot;, EtcdConfig:apiconfig.EtcdConfig{EtcdEndpoints:\u0026quot;https://sp2srvvpkv00001:2379\u0026quot;, EtcdDiscoverySrv:\u0026quot;\u0026quot;, EtcdUsername:\u0026quot;\u0026quot;, EtcdPassword:\u0026quot;\u0026quot;, EtcdKeyFile:\u0026quot;\u0026quot;, EtcdCertFile:\u0026quot;\u0026quot;, EtcdCACertFile:\u0026quot;tls/tls.ca\u0026quot;, EtcdKey:\u0026quot;\u0026quot;, EtcdCert:\u0026quot;\u0026quot;, EtcdCACert:\u0026quot;\u0026quot;}, KubeConfig:apiconfig.KubeConfig{Kubeconfig:\u0026quot;\u0026quot;, K8sAPIEndpoint:\u0026quot;\u0026quot;, K8sKeyFile:\u0026quot;\u0026quot;, K8sCertFile:\u0026quot;\u0026quot;, K8sCAFile:\u0026quot;\u0026quot;, K8sAPIToken:\u0026quot;\u0026quot;, K8sInsecureSkipTLSVerify:false, K8sDisableNodePoll:false, K8sUsePodCIDR:false, KubeconfigInline:\u0026quot;\u0026quot;, K8sClientQPS:0}} ... ^C Enfim, você não pode confiar que o calicoctl irá te contar se houver qualquer tipo de falha na validação TLS, seja ela do lado do servidor ou do cliente.\nA mensagem que me permitiu diagnosticar adequadamente o problema foi a consulta dos logs dos servidores ETCD diretamente:\nOct 15 12:18:29 etcd1.local docker[832]: 2020-10-15 15:18:29.066104 I | embed: rejected connection from \u0026quot;192.168.255.42:54608\u0026quot; (error \u0026quot;tls: failed to verify client's certificate: x509: certificate has expired or is not yet valid\u0026quot;, ServerName \u0026quot; etcd1.local\u0026quot;) Oct 15 12:18:59 etcd1.local docker[832]: 2020-10-15 15:18:59.136121 I | embed: rejected connection from \u0026quot;192.168.255.42:56290\u0026quot; (error \u0026quot;tls: failed to verify client's certificate: x509: certificate has expired or is not yet valid\u0026quot;, ServerName \u0026quot; etcd1.local\u0026quot;) Aqui, diagnóstico trivial: os pseudo administradores deste ambiente deixaram os certificados do cliente calicoctl expirarem.\n Conclusão:\n Conectividade TLS pode ser um horror para depurar; Se você gera certificados para sua Intranet, implemente um controle adequado para saber quando estes estiverem próximos de expirar;  ",
    "ref": "/marcelo/blog/calicoctl-stuck/"
  },{
    "title": "Cuidado com terraform import",
    "date": "",
    "description": "Importando recursos que usam count e for_each",
    "body": "(Nota: eu tenho tentado produzir conteúdo de qualidade seguindo uma linha de raciocínio com começo, meio e fim, com valor histórico e altamente apreciável. Com isso, meu último post foi mês passado e eu tenho mais de 30 drafts a concluir. Portanto, vou tornar isso aqui um braindump de conteúdos aleatórios que eu julgar relevante. Foi mal!)\n Quem não adora Terraform?\nBasta escrever meia dúzia de arquivos que algum programa magicamente interpreta tudo e cria coisas mágicas para você. Fantástico! O único problema é aprender a usar direito.\nA Hashicorp, até alguns anos atrás, fazia documentações tão crípticas e ilegíveis que eventualmente perceberam que era necessário um esforço maior para \u0026ldquo;mentes menores\u0026rdquo; compreenderem seus softwares. Com isso, investiram somas substanciais de dinheiro fazendo sites como o Learn Hashicorp ou mesmo workshops gratuitos interativos com Instruqt. Eles realmente têm feito um bom trabalho nessa seara.\nEm muitos aspectos, o Terraform ainda é deficiente.\nÀs vezes é pura frescura: vide o terraform-provider-kubernetes, que simplesmente se recusava a implementar APIs betas por anos, tornando-o praticamente inútil. E mesmo quando deployments chegaram à GA, demorou quase um ano para implementar este elemento que é considerado como pedra fundamental para qualquer aplicação Kubernetes.\nMas muitas vezes nem é culpa da Hashicorp: a integração com VMware, mesmo com as últimas funcionalidades implementadas pela última versão, é, literalmente, um horror. E o problema aqui são as severas limitações funcionais das APIs públicas disponibilizadas pela própria VMWare.\nMas chega de \u0026lsquo;rant\u0026rsquo;: vamos a conteúdo!\nTerraform import Todo mundo sabe que o Terraform precisa de total controle sobre o que cria; o que existe tem que ser criado por ele, e isso é inegociável.\nQuer dizer, nem tanto; eles dão uma colher de chá para você tentar adaptar uma infraestrutura já existente à sua automação: o comando terraform import.\nSuponha que, agora, você usa Terraform e conseguiu criar 2 máquinas usando seu novíssimo programa! Como você faz para \u0026lsquo;incorporar\u0026rsquo; as 2000 máqunas que já existem na sua infraestrutura? Executando 2000 vezes (no mínimo) o comando \u0026lsquo;import\u0026rsquo; especificando os \u0026lsquo;terraform resources\u0026rsquo; que as máquinas representam, bem como um identificador alienígena que varia completamente de maneira praticamente imprevisível de acordo com o tipo de \u0026lsquo;provider\u0026rsquo;! (Tudo bem, é melhor que toda infraestrutura tem que ser criado por ele e isso ser inegociável).\nNosso problema: cluster Kubernetes com 10 máquinas virtuais usando VMWare Vsphere. Precisamos adicionar mais 4. Obviamente não usamos Terraform no passado. Como fazer?\nComando da documentação oficial:\nterraform import vsphere_virtual_machine.vm /dc1/vm/srv1 O colega com pouca experiência que está trilhando os tortuosos caminhos dos programas Terraform criados por mim (que consigo ser ainda mais críptico que a própria Hashicorp) falou:\n \u0026ldquo;Ufa! Ainda bem que é só isso, certo?\u0026rdquo;\n Claro que não!\n Se o seu programa (tipo, literalmente, no diretório corrente) criar \u0026lsquo;resources\u0026rsquo; do tipo \u0026lsquo;vsphere_virtual_machine\u0026rsquo; que sejam escalares (i.e., não usem \u0026lsquo;for_each\u0026rsquo; ou \u0026lsquo;count'), o primeiro parãmetro do comando está correto. Caso contrário, está errado! /dc1/vm/srv1 é obviamente um placeholder; você precisa descobrir o \u0026lsquo;caminho VMware\u0026rsquo; das suas máquinas virtuais, e, se você não entende de VMWare, pode ter alguma dificuldade com a nomenclatura.  A segunda parte é fácil: basta compor o nome do datacenter com a string arbitrária vm com as \u0026lsquo;pastas\u0026rsquo; criadas no Vcenter e, por fim, o nome dos servidores:\n \u0026ldquo;/bsa/vm/infra/10069/kubernetes df1/hosts/master1\u0026rdquo; \u0026ldquo;/bsa/vm/infra/10069/kubernetes df1/hosts/master2\u0026rdquo; \u0026ldquo;/bsa/vm/infra/10069/kubernetes df1/hosts/worker1\u0026rdquo; \u0026ldquo;/bsa/vm/infra/10069/kubernetes df1/hosts/worker2\u0026rdquo;  Tranquilo. (Espero que tenha acesso à API do VMWare para descobrir isso!)\nA primeira parte, por outro lado, irá variar radicalmente de acordo com o Terraform que você está usando.\nEm nosso caso, por exemplo, eu criei um módulo terraform que encapsula a criação dos recursos VMWare VSphere necessários. Esse encapsulamento \u0026lsquo;vaza\u0026rsquo; por uma série de razões, mas me permite passar as máquinas como uma variável map para o módulo mais ou menos da seguinte forma:\nvms = { \u0026quot;master1\u0026quot; = { \u0026quot;profile\u0026quot; = \u0026quot;k8s_worker\u0026quot; \u0026quot;hostname\u0026quot; = \u0026quot;master1\u0026quot; \u0026quot;network\u0026quot; = { \u0026quot;rede1\u0026quot; = \u0026quot;192.168.0.1\u0026quot;, \u0026quot;rede2\u0026quot; = \u0026quot;10.0.0.1\u0026quot; } } \u0026quot;worker1\u0026quot; = { \u0026quot;profile\u0026quot; = \u0026quot;k8s_worker\u0026quot; \u0026quot;hostname\u0026quot; = \u0026quot;worker1\u0026quot; \u0026quot;network\u0026quot; = { \u0026quot;rede1\u0026quot; = \u0026quot;192.168.0.101\u0026quot;, \u0026quot;rede2\u0026quot; = \u0026quot;10.0.0.101\u0026quot;, \u0026quot;rede3\u0026quot; = \u0026quot;172.16.0.1\u0026quot;, } } \u0026quot;ingress1\u0026quot; = { \u0026quot;profile\u0026quot; = \u0026quot;k8s_ingress\u0026quot; \u0026quot;hostname\u0026quot; = \u0026quot;ingress1\u0026quot; \u0026quot;network\u0026quot; = { \u0026quot;rede1\u0026quot; = \u0026quot;192.168.0.201\u0026quot;, \u0026quot;rede2\u0026quot; = \u0026quot;10.0.0.201\u0026quot;, \u0026quot;rede4\u0026quot; = \u0026quot;200.160.2.1\u0026quot;, } }  (E aqui, um conselho: evite ao máximo criar maps de maps de maps ou maps de arrays de maps como eu gosto de fazer. É uma ideia idiota, que deixa seu programa Terraform praticamente incompreensível para seres humanos. Eu adoro fazer assim por razões, mas definitivamente não recomendo).\n Enfim, a criação dos meus resources estão encapsulados no módulo.\nEntão, o comando \u0026lsquo;terraform import\u0026rsquo; deve, necessariamente, fazer referência ao resource dentro do módulo:\n module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm  E aqui está a pegadinha: aqui está a definição do meu resource vm:\nresource \u0026quot;vsphere_virtual_machine\u0026quot; \u0026quot;vm\u0026quot; { for_each = local.vms name = each.value.hostname ... Portanto, o meu \u0026lsquo;resource\u0026rsquo; vm não é um tipo simples (ou escalar, como eu chamo), e sim um tipo complexo (por causa do uso do iterador for_each) do tipo map.\nO comando correto para importar máquinas já existentes, portanto, é assim:\n# terraform import \u0026#39;module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm[\u0026#34;master2\u0026#34;]\u0026#39; \u0026#39;/bsa/vm/infra/10069/kubernetes df1/hosts/master2\u0026#39; # terraform import \u0026#39;module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm[\u0026#34;worker2\u0026#34;]\u0026#39; \u0026#39;/bsa/vm/infra/10069/kubernetes df1/hosts/worker2\u0026#39; ... Tá, mas e daí? E daí que: o que pode acontecer se eu executar o comando errado?\n# terraform import module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm \u0026#39;/bsa/vm/infra/10069/kubernetes df1/hosts/worker2\u0026#39; Acima, erramos o comando, e importamos \u0026lsquo;worker2\u0026rsquo;, que deveria ser membro de um map, para vsphere_virtual_machine.vm do módulo diretamente.\nO que se espera normalmente? Um erro de execução, certo?\nVai dar erro, mas não no import. O import irá executar de maneira bem sucedida. Mas, depois disso, provavelmente tudo relacionado a este programa falhará.\nApós a execução do comando errado, fui agraciado com a seguinte mensagem:\n# terraform apply ... module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm[\u0026quot;ingress3\u0026quot;]: Refreshing state... [id=421ab407-1bc3-dceb-6906-72fe3fad4c0e] Error: Unsupported attribute on .terraform/modules/vmware-cluster-k8s-raw/locals.tf line 104, in locals: 104: vms_result = { for key, value in vsphere_virtual_machine.vm : key =\u0026gt; { for network in value.network_interface : network.network_id =\u0026gt; network.mac_address } } O que esse erro quer dizer? Quer dizer que aquela sequência mágica de \u0026lsquo;terraform maps comprehension\u0026rsquo; falhou. Por quê? Putz, vai adivinhar.\nMeu colega aplicou um \u0026ldquo;Senhor, eu desisto, Senhor!\u0026quot;:\n  E isso, obviamente, faz qualquer sênior SRE muito feliz!\n Como fui eu que pari a besta, voltei para entender.\nObservei o seguinte descrevendo o arquivo de estados:\n# terraform state list module.vmware-cluster-k8s-raw.data.vsphere_compute_cluster.compute_cluster module.vmware-cluster-k8s-raw.data.vsphere_datacenter.cluster_datacenter module.vmware-cluster-k8s-raw.data.vsphere_datastore_cluster.cluster_datastore module.vmware-cluster-k8s-raw.data.vsphere_network.networks[\u0026quot;cluster\u0026quot;] module.vmware-cluster-k8s-raw.data.vsphere_network.networks[\u0026quot;ingress\u0026quot;] module.vmware-cluster-k8s-raw.data.vsphere_network.networks[\u0026quot;management\u0026quot;] module.vmware-cluster-k8s-raw.data.vsphere_network.networks[\u0026quot;storage\u0026quot;] module.vmware-cluster-k8s-raw.vsphere_folder.folder module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm[\u0026quot;worker1\u0026quot;] module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm[\u0026quot;worker2\u0026quot;] Algo estranho aqui: temos dois tipos de ocorrências para o objeto que representa o map vm:\n module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm: um \u0026lsquo;escalar\u0026rsquo;! module.vmware-cluster-k8s-raw.vsphere_virtual_machine.vm[]: este sim com todas as ocorrências adequadas!  O comando errado de import criou uma entrada errada no \u0026lsquo;state file\u0026rsquo; que bagunçou o funcionamento da lógica do módulo.\nNossa situação foi um pouco pior, porque o comando gerou a máquina em um lugar no VMWare que ela não deveria ser criada por razões desconhecidas (novamente, em vez de dar erro!), e que não tínhamos permissão para remover também por razões desconhecidas.\nA solução para este caso foi a remoção da máquina problemática do \u0026lsquo;map\u0026rsquo; de objetos criados; após um apply bem sucedido com a remoção da máquina problemática, o Terraform foi capaz de perceber o desvio no arquivo de estado e corrigiu sozinho, removendo a entrada inválida e me poupando (desta vez!) a experiência aterrorizante de manipular o estado com \u0026lsquo;terraform state\u0026rsquo;, então, se era para isos que você veio aqui, desculpe frustrar sua expectativa!\n Para aprender com esta experiência:\n Criar módulos Terraform para tudo parece uma ideia genial, mas quanto mais você encapsula achando que está reusando código, mais estará duplicando entradas de variáveis e se distanciando das validações básicas do programa; Evite usar de maneira leviana maps, arrays, counts e for_eachs a menos que você esteja disposto a ir até o fim por suas escolhas - ou trabalhe com alguém insano que use em todo canto; aí, meu amigo, meus pêsames; Não execute \u0026lsquo;imports\u0026rsquo; até ter certeza absoluta do que está fazendo.  ",
    "ref": "/marcelo/blog/terraform-import-watch-out/"
  },{
    "title": "Por que Docker?",
    "date": "",
    "description": "Docker e contêiners - razões diretas e pragmáticas perdidas em um texto bem menos direto e pragmático",
    "body": "Em conversas - principalmente com pessoas dos dois extremos do espectro de idade - sobre nosso glorioso mercado de TI vez por outra surge este questionamento: por que usar Docker?\nEu tendo a reclamação, em especial de estudantes e do pessoal novo: em casa, sem um arsenal de ferramentas de CI/CD implantadas por terceiros, parece uma incrível bobagem e perda de tempo. Dockerfile, rede virtual, putz, pra que complicar, se eu posso rodar tudo na minha máquina sem problemas?\n(Já o pessoal antigo, é preguiça e má vontade: vá aprender a usar contêineres e saia da zona de conforto imediatamente!)\nPor que Docker? Essa resposta é trivial:\nDocker é simples; Docker é fácil de entender; Docker \u0026ldquo;faz tudo\u0026rdquo;.\nDocker abstrai a infinidade de detalhes necessários para a execução de contêineres no Linux com um cobertor quente, bonito e agradável que permite ao seu usuário ser produtivo com um mínimo de overhead no aprendizado de uma tecnologia \u0026ldquo;colateral\u0026rdquo;.\nE mais: o \u0026ldquo;engine Docker\u0026rdquo; vai muito além: o software veio cuidar de praticamente todas as etapas do ciclo de vida de um contêiner, desde sua criação até viabilizar que as imagens cheguem onde desejamos - seja no host, seja no Docker Registry, mantido pelo Docker! -, passando pela execução e manutenção dos containers e imagens no servidor.\nExiste uma pergunta muito mais difícil, que inclusive muitos administradores de sistemas que usam contêineres todos os dias nos últimos anos não sabe responder:\nSe você não usar Docker, vai usar o quê?\nAté mesmo pesquisar essa resposta é difícil1; muitos dos conteúdos disponíveis sobre o assunto estão ou extremamente defasados ou simplesmente errados em suas comparações. A resposta a essa pergunta não atende às necessidades da maioria dos profissionais de TI, logo é irrelevante (você tem interesse na resposta? Se sim, me deixe saber!).\nEnquanto a \u0026ldquo;concorrência\u0026rdquo; não trabalhar isso, Docker será o líder incontestável em uso.\nPor que containers? Falando a verdade, a pergunta correta não é \u0026ldquo;por que usar Docker\u0026rdquo;, e sim, por que usar contêineres. Esta sim, diferentemente da primeira, é uma pergunta sem resposta direta e imediata.\nEu poderia copiar definições, justificativas e citar mil livros ou páginas importantes explicando o porquê da relevância da tecnologia de conteinerização sob as diferentes óticas2. Mas, em verdade, o que falta para muitos é entender que problemas essa tecnologia veio resolver, e que pode ser resumido em uma sentença:\nContêineres resolvem o problema de \u0026ldquo;na minha máquina funciona!\u0026rdquo;.\nHistoricamente, sempre coube aos profissionais de infraestrutura o processo de implantação, manutenção e resolução de problemas em ambientes que executam programas elaborados por terceiros. E um desafio tradicional dessa época era a divergência entre os ambientes em que os softwares eram desenvolvidos, homologados e, por fim, postos em produção.\nNão era incomum ajustes nos ambientes serem feitos \u0026ldquo;em tempo de homologação\u0026rdquo; para corrigir problemas e se perderem na \u0026ldquo;não documentação\u0026rdquo; do sistema, que era passada para as áreas de operações implantarem (e, consequentemente, falharem). Também não era incomum o uso de plataformas radicalmente diferentes e incompatíveis entre si, gerando conflitos homéricos sobre o uso de versão de um sistema operacional não internalizado pela empresa, ou a necessidade de atualização de um serviço para uma tecnologia de pouco domínio por parte dos administradores de serviços. Mesmo para tecnologias que naturalmente são pensadas para \u0026ldquo;rodar em todo lugar\u0026rdquo;, como Java, encontra problemas com versões e parametrizações específicas que podem se perder na transição entre ambientes.\nContêineres, por definição, resolvem o problema de \u0026ldquo;reproducibilidade de resultados\u0026rdquo;, ou \u0026ldquo;portabilidade\u0026rdquo; das aplicações: uma imagem Docker é gerada para a sua aplicação, com todos os arquivos (como elementos do sistema operacional, bibliotecas e utilitários) e configurações necessários para sua execução. Uma consequência comum da adoção deste modelo é a obrigatoriedade de adoção de um mínimo de boas práticas, como por exemplo a parametrização para que a aplicação receba configurações que variam de ambiente para ambiente.\nEste problema já foi amplamente abordado no passado como virtualização de servidores e tecnologias de orquestração e gestão de configuração; nenhuma delas, entretanto, resolveu com a elegância e simplicidade de simplesmente \u0026ldquo;socar\u0026rdquo; tudo que é necessário em uma unidade parametrizável e orquestrável.\nA partir desta entidade Contêiner3 que trivializa a implantação (\u0026quot;deploy\u0026quot;) de um software, está aberto agora o caminho para a construção de novas soluções que resolvam outros problemas do processo de desenvolvimento de software e otimizem ainda mais o processo de entrega de resultados por parte das equipes.\n 1 Os melhores links sequer apareciam na página principal do Google:\n A Comprehensive Container Runtime Comparison Aquasec: Docker Alternatives  2 \u0026ldquo;Ópticas\u0026rdquo; é muito feio.\n3 Observe que, no Linux, \u0026ldquo;Contêiner\u0026rdquo; não é uma primitiva do sistema operacional, e sim um conjunto destas. Do ponto de vista prático, acaba sendo uma.\n",
    "ref": "/marcelo/blog/why-docker/"
  },{
    "title": "Sobre",
    "date": "",
    "description": "",
    "body": "O fundador da DevSREs Network Initiative, Marcelo Andrade, é entusiasta do universo Linux e software livre desde a primeira instalação do saudoso Conectiva Parolin em1997.\nAo longo dos anos, transitou profissionalmente entreos mais diversos nomes comumente atribuídos aos profissionais de TI que não trabalham diretamente com desenvolvimento de software: sysop, sysadmin, adminisstrador de redes, analista de redes, analista de infraestrutura, analista de suporte, engenheiro de soluções\u0026hellip; Até auto instituir o título de Site Reliability Engineer, ou engenheiro de confiabilidade (de sites?) em português.\nA realidade é que, em todas elas, o foco é sempre o mesmo: manter ambientes on-line, garantindo performance, escalabilidade e confiabilidade aos sistemas da empresa. O que muda, com os anos, é abordagem e o conjunto de ferramentas a ser usado.\nSeu principal nicho de atuação, no momento, é a manutenção de clusters Kubernetes em conjuto com outras tecnologias Cloud Native (ou nem tanto).\n",
    "ref": "/marcelo/about/"
  },{
    "title": "Kubernetes: por onde começar",
    "date": "",
    "description": "Como dar os primeiros passos nesta tecnologia",
    "body": "No último ano, aqui em Recife, tive a oportunidade de participar (e palestrar!) em alguns eventos. Em comum, havia o fato de muito de seus conteúdos - se não integralmente - estarem relacionados ao Kubernetes.\nNas duas oportunidade em que fiz apresentações, entrei em detalhes sobre:\n o desafio de usar o objeto Ingress - que, até a recém-lançada versão 1.19, ainda era beta, embora exista desde a versão 1.1; uma nova abordagem de como fazer a gerência de um cluster e a entrega contínua de aplicações: GitOps;  Embora eu sempre procure abordar o assunto de uma forma que não seja absolutamente incompreensível para quem não tenha qualquer tipo de contato com Kubernetes, em todos os eventos, me deparo com uma realidade: a de que existe muita gente interessada sobre Kubernetes, mas com bastante dificuldade de se introduzir a esta tecnologia.\nSempre me é feita uma pergunta: por onde começar? Como dou os primeiros passos? E eu nunca tenho uma resposta de qualidade a oferecer: eu já \u0026ldquo;aprendi tudo\u0026rdquo; lá atrás, em um passado remoto no qual inexistia bons tutorials ou cursos, e a documentação descrevia o Kube Controller como \u0026ldquo;the program that runs the control loops that controls the state of objects\u0026rdquo; (ou algo assim).\nFelizmente, os tempos mudaram, e é ampla a documentação de cada mínimo aspecto relacionado ao Kubernetes, com bastante oferta de cursos (pagos e gratuitos) sobre o assunto.\nSem mais delongas, por onde começar quando quer se aprender sobre Kubernetes?\nKubeAcademy  https://kube.academy/  A VMware disponibilizou um excelente material (e, vale ressaltar completamente gratuito) sobre containers e Kubernetes. Os conteúdos são apresentados de maneira fácil de digerir, e alguns dos cursos inclusive contam com laboratórios práticos interativos com Katacoda, o que, na minha opinião, torna este conteúdo possivelmente o melhor disponível para uma apresentação inicial.\nA desvantagem para quem não domina o inglês é o uso de player próprio e a inexistência de legendas, embora seja possível regular a velocidade do player para melhorar a compreensão para aqueles não tão fluentes.\nKatacoda / instruqt  https://www.katacoda.com https://play.instruqt.com/public  O Katacoda, adquirido recentemente pela tradicional editora de livros técnicos O\u0026rsquo;Reilly, por muito tempo, serviu como laboratório prático para quem não tem recursos para subir um cluster Kubernetes para prática pessoal.\nOs cursos dno Katacoda são interativos e executados diretamente no navegador, o que torna o processo simples e dinâmico. Antes de produção restrita, agora o Katacoda permite que qualquer um disposto a aprender a usar a plataforma possa criar seus próprios cursos com ela - o que\nO ponto negativo é que a maneira de abordar o conteúdo teórico fica em segundo plano. E, acredite, muito do trabalhar bem com Kubernetes adequadamente vem de entender a maneira e o porquê optou-se por resolver os problemas desta forma.\nInstruqt é bastante semelhante em abordagem ao Katacoda; mas, no geral, a interface apresenta mais problemas e os cursos de Kubernetes em qualidade inferior.\nKubernetes.io A documentação do projeto vem crescendo em volume e qualidade a olhos vistos a cada versão que passa. A versão 1.18 introduziu a oferta em outros idiomas que não o inglês, o que nem imaginava que fosse acontecer algum dia.\nO destaque da documentação fica por parte dos conceitos. Muitos dos textos crípticos do começo foram reescritos de maneira compreensível, e agora as ideias são, sim, plenamente acessíveis ao \u0026ldquo;grande público\u0026rdquo;.\nVale a pena mencionar que a documentação conta com duas seções extremamente valiosas para quem está aprendendo e pensa em tirar a certificação CKA/CKAD: a seção de Tasks e a de Tutoriais.\nEmbora o português esteja lá, a maior parte das páginas que acessei ainda está disponível apenas em inglês.\nEDX - Introduction to Kubernetes https://www.edx.org/course/introduction-to-kubernetes\nLembro que, à medida que novos membros chegavam à equipe, a recomendação padrão era a fazer este curso do EDX elaborado pela Linux Foundation - basicamente porque era a única opção.\nÉ possível ler grande parte dos conteúdos disponíveis sem custo adicional, mas vários recursos são oferecidos apenas aos pagantes.\nDeixo aqui esta entrada pelo valor histórico, mas acredito que a relevância deste curso hoje é limitada se comparado ao que já é oferecido pela documentação oficial do Kubernetes.\nMas e em português? Aqui, eu peço desculpas, mas vou ficar devendo.\nA qualidade dos materiais que tive a oportunidade de ler (inclusive em sites pagos) está entre o ruim e o sofrível. Então, não tenho uma boa recomendação a oferecer.\n Se você conhecer algum bom site com conteúdo de Kubernetes em português e quiser recomendar, entre em contato por qualquer uma das minhas redes sociais que eu terei um prazer enorme em incluí-los nesta lista!\n",
    "ref": "/marcelo/blog/kubernetes-where-to-start/"
  },{
    "title": "Contact",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/marcelo/contact/"
  }]
